# NOTE: This is automatically generated by `python -m cuisine.api -t impl`, do not edit
from typing import Tuple, List, Dict, Optional, Union, ForwardRef, ContextManager
import cuisine.connection
import pathlib
from ._stub import API as Interface
class API(Interface):

     def __init__(self):
          import cuisine.api.command as cuisine_api_command
          import cuisine.api.config as cuisine_api_config
          import cuisine.api.connection as cuisine_api_connection
          import cuisine.api.dir as cuisine_api_dir
          import cuisine.api.env as cuisine_api_env
          import cuisine.api.file as cuisine_api_file
          import cuisine.api.package as cuisine_api_package
          import cuisine.api.packages_python as cuisine_api_packages_python
          import cuisine.api.ssh as cuisine_api_ssh
          import cuisine.api.tmux as cuisine_api_tmux
          import cuisine.api.user as cuisine_api_user
          self._command = cuisine_api_command.CommandAPI(self)
          self._configuration = cuisine_api_config.Configuration(self)
          self._connection = cuisine_api_connection.Connection(self)
          self._dir = cuisine_api_dir.DirAPI(self)
          self._environment = cuisine_api_env.Environment(self)
          self._file = cuisine_api_file.FileAPI(self)
          self._package = cuisine_api_package.PackageAPI(self)
          self._packageapt = cuisine_api_package.PackageAPTAPI(self)
          self._packageyum = cuisine_api_package.PackageYUMAPI(self)
          self._pythonpippackage = cuisine_api_packages_python.PythonPIPPackage(self)
          self._pythonpackage = cuisine_api_packages_python.PythonPackageAPI(self)
          self._ssh = cuisine_api_ssh.SSHAPI(self)
          self._tmux = cuisine_api_tmux.TmuxAPI(self)
          self._linuxuser = cuisine_api_user.LinuxUserAPI(self)
          self._user = cuisine_api_user.UserAPI(self)

     def command(self, name: str) -> str:
          """Returns the normalized command name. This first tries to find a match
        in `DEFAULT_COMMANDS` and extract it, and then look for a `COMMAND_{name}`
        in the environment."""
          return self._command.command(name)

     def command_check(self, command: str) -> bool:
          """Tests if the given command is available on the system."""
          return self._command.command_check(command)

     def command_ensure(self, command: str, package=None) -> bool:
          """Ensures that the given command is present, if not installs the
        package with the given name, which is the same as the command by
        default."""
          return self._command.command_ensure(command, package)

     def config_clear(self, variable: str) -> Optional[str]:
          """Clears the given `variable` from connection's environment.
        `default` if not found."""
          return self._configuration.config_clear(variable)

     def config_get(self, variable: str, default: Optional[str] = None) -> Optional[str]:
          """Returns the given `variable` from the connection's environment, returning
        `default` if not found."""
          return self._configuration.config_get(variable, default)

     def config_get_variant(self, group: str) -> Optional[str]:
          """None"""
          return self._configuration.config_get_variant(group)

     def config_has(self, variable: str) -> bool:
          """Sets the given `variable` in the connection's environment, returning
        `default` if not found."""
          return self._configuration.config_has(variable)

     def config_set(self, variable: str, value: str) -> str:
          """Sets the given `variable` in the connection's environment, returning
        `default` if not found."""
          return self._configuration.config_set(variable, value)

     def cd(self, path: str) -> ContextManager:
          """Changes the current connection path, returning a context that can be
        used like so:

        ```python
        cd("~")
        with cd("/etc"):
            run("ls -l")
        # Current path will be "~"
        ```
        """
          return self._connection.cd(path)

     def connect(self, host=None, port=None, user=None, password=None, key: Union[str, pathlib.Path] = None, transport: Optional[str] = None) -> ContextManager:
          """Connects to the given host/port using the given user/password/key_path credentials. Note that
        not all connection types support all these arguments, so you might get warnings if they are
        not supported."""
          return self._connection.connect(host, port, user, password, key, transport)

     def connect_local(self) -> ContextManager:
          """None"""
          return self._connection.connect_local()

     def connect_mitogen(self, host=None, port=None, user=None, password=None, key: Optional[pathlib.Path] = None) -> ContextManager:
          """None"""
          return self._connection.connect_mitogen(host, port, user, password, key)

     def connect_paramiko(self, host=None, port=None, user=None, password=None, key: Optional[pathlib.Path] = None) -> ContextManager:
          """None"""
          return self._connection.connect_paramiko(host, port, user, password, key)

     def connect_tmux(self, session: str, window: str) -> ContextManager:
          """Creates a new connection using the TmuxConnection"""
          return self._connection.connect_tmux(session, window)

     def connection(self) -> cuisine.connection.Connection:
          """Returns the current connection"""
          return self._connection.connection()

     def detect_connection(self) -> str:
          """Detects the recommended type of connection"""
          return self._connection.detect_connection()

     def disconnect(self) -> Optional[cuisine.connection.Connection]:
          """Disconnects from the current connection unless it'"s the default
        local connection."""
          return self._connection.disconnect()

     def fail(self, message: Optional[str] = None):
          """None"""
          return self._connection.fail(message)

     def is_local(self) -> bool:
          """Tells if the current connection is local or not."""
          return self._connection.is_local()

     def run(self, command: str) -> 'CommandOutput':
          """None"""
          return self._connection.run(command)

     def run_local(self, command: str) -> 'CommandOutput':
          """None"""
          return self._connection.run_local(command)

     def select_connection(self, type: str) -> bool:
          """Selects the default type of connection. This returns `False` in case
        the connection is not found."""
          return self._connection.select_connection(type)

     def sudo(self, command: Optional[str] = None) -> Union[ContextManager, ForwardRef('CommandOutput')]:
          """None"""
          return self._connection.sudo(command)

     def dir_attribs(self, path: str, mode=None, owner=None, group=None, recursive=False):
          """Updates the mode/owner/group for the given remote directory."""
          return self._dir.dir_attribs(path, mode, owner, group, recursive)

     def dir_ensure(self, path: str, recursive=True, mode=None, owner=None, group=None) -> str:
          """Ensures that there is a remote directory at the given path,
        optionally updating its mode/owner/group.

        If we are not updating the owner/group then this can be done as a single
        ssh call, so use that method, otherwise set owner/group after creation."""
          return self._dir.dir_ensure(path, recursive, mode, owner, group)

     def dir_ensure_parent(self, path: str):
          """Ensures that the parent directory of the given path exists"""
          return self._dir.dir_ensure_parent(path)

     def dir_exists(self, path: str) -> bool:
          """Tells if there is a remote directory at the given path."""
          return self._dir.dir_exists(path)

     def dir_remove(self, path: str, recursive=True):
          """ Removes a directory """
          return self._dir.dir_remove(path, recursive)

     def env_clear(self, variable: str) -> str:
          """Clears the given `variable` from connection's environment.
        `default` if not found."""
          return self._environment.env_clear(variable)

     def env_get(self, variable: str, default: Optional[str] = None) -> str:
          """Returns the given `variable` from the connection's environment, returning
        `default` if not found."""
          return self._environment.env_get(variable, default)

     def env_set(self, variable: str, value: str) -> str:
          """Sets the given `variable` in the connection's environment, returning
        `default` if not found."""
          return self._environment.env_set(variable, value)

     def file_append(self, path: str, content: Union[bytes, str], mode: Optional[str] = None, owner: Optional[str] = None, group: Optional[str] = None):
          """Appends the given content to the remote file at the given
        path, optionally updating its mode/owner/group."""
          return self._file.file_append(path, content, mode, owner, group)

     def file_attribs(self, path: str, mode=None, owner=None, group=None):
          """Updates the mode/owner/group for the remote file at the given
        path."""
          return self._file.file_attribs(path, mode, owner, group)

     def file_attribs_get(self, path: str) -> Dict[str, str]:
          """Return mode, owner, and group for remote path.
        Return mode, owner, and group if remote path exists, 'None'
        otherwise.
        """
          return self._file.file_attribs_get(path)

     def file_backup(self, path: str, suffix='.orig', once=False):
          """Backups the file at the given path in the same directory, appending
        the given suffix. If `once` is True, then the backup will be skipped if
        there is already a backup file."""
          return self._file.file_backup(path, suffix, once)

     def file_base64(self, path: str) -> str:
          """Returns the base64-encoded content of the file at the given path."""
          return self._file.file_base64(path)

     def file_ensure(self, path, mode=None, owner=None, group=None, scp=False):
          """Updates the mode/owner/group for the remote file at the given
        path."""
          return self._file.file_ensure(path, mode, owner, group, scp)

     def file_exists(self, path: str) -> bool:
          """Tests if there is a *remote* file at the given path."""
          return self._file.file_exists(path)

     def file_is_dir(self, path: str) -> bool:
          """Tells if the given path is a directory or not"""
          return self._file.file_is_dir(path)

     def file_is_file(self, path: str):
          """Tells if the given path is a file or not"""
          return self._file.file_is_file(path)

     def file_is_link(self, path: str) -> bool:
          """Tells if the given path is a symlink or not"""
          return self._file.file_is_link(path)

     def file_link(self, source, destination, symbolic=True, mode=None, owner=None, group=None):
          """Creates a (symbolic) link between source and destination on the remote host,
        optionally setting its mode/owner/group."""
          return self._file.file_link(source, destination, symbolic, mode, owner, group)

     def file_md5(self, path: str):
          """Returns the MD5 sum (as a hex string) for the remote file at the given path."""
          return self._file.file_md5(path)

     def file_name(self, path: str) -> str:
          """Returns the file name for the given path."""
          return self._file.file_name(path)

     def file_read(self, path: str) -> bytes:
          """Reads the *remote* file at the given path, if default is not `None`,
        default will be returned if the file does not exist."""
          return self._file.file_read(path)

     def file_read_str(self, path: str) -> str:
          """None"""
          return self._file.file_read_str(path)

     def file_sha256(self, path: str):
          """Returns the SHA-256 sum (as a hex string) for the remote file at the given path."""
          return self._file.file_sha256(path)

     def file_unlink(self, path: str):
          """Removes the given file path if it exists"""
          return self._file.file_unlink(path)

     def file_update(self, path: str, updater=None):
          """Updates the content of the given by passing the existing
        content of the remote file at the given path to the 'updater'
        function. Return true if file content was changed.

        For instance, if you'd like to convert an existing file to all
        uppercase, simply do:

        >   file_update("/etc/myfile", lambda _:_.upper())

        Or restart service on config change:

        >   if file_update("/etc/myfile.cfg", lambda _: text_ensure_line(_, line)): run("service restart")
        """
          return self._file.file_update(path, updater)

     def file_upload(self, local: str, remote: str):
          """Uploads the local file to the remote path only if the remote path does not
        exists or the content are different."""
          return self._file.file_upload(local, remote)

     def file_write(self, path: str, content: Union[str, bytes], mode=None, owner=None, group=None, sudo=None, check=True, scp=False):
          """Writes the given content to the file at the given remote
        path, optionally setting mode/owner/group."""
          return self._file.file_write(path, content, mode, owner, group, sudo, check, scp)

     def user_create_linux(self, name: str, passwd: Optional[str] = None, home: Optional[str] = None, uid: Optional[int] = None, gid: Optional[int] = None, shell: Optional[str] = None, uid_min: Optional[int] = None, uid_max: Optional[int] = None, encrypted_passwd: Optional[bool] = True, fullname: Optional[str] = None, create_home: Optional[bool] = True):
          """None"""
          return self._linuxuser.user_create_linux(name, passwd, home, uid, gid, shell, uid_min, uid_max, encrypted_passwd, fullname, create_home)

     def user_ensure_linux(self, name: str, passwd: Optional[str] = None, home: Optional[str] = None, uid: Optional[int] = None, gid: Optional[int] = None, shell: Optional[str] = None, uid_min: Optional[int] = None, uid_max: Optional[int] = None, encrypted_passwd: Optional[bool] = True, fullname: Optional[str] = None, create_home: Optional[bool] = True):
          """None"""
          return self._linuxuser.user_ensure_linux(name, passwd, home, uid, gid, shell, uid_min, uid_max, encrypted_passwd, fullname, create_home)

     def user_exists_linux(self, name: str) -> bool:
          """None"""
          return self._linuxuser.user_exists_linux(name)

     def user_get_linux(self, name: str = None, uid: int = None):
          """None"""
          return self._linuxuser.user_get_linux(name, uid)

     def user_passwd_linux(self, name: str, passwd: str, encrypted_passwd=True):
          """Sets the given user password. Password is expected to be encrypted by default."""
          return self._linuxuser.user_passwd_linux(name, passwd, encrypted_passwd)

     def user_remove_linux(self, name: str, remove_home: bool = False):
          """Removes the user with the given name, optionally
        removing the home directory and mail spool."""
          return self._linuxuser.user_remove_linux(name, remove_home)

     def detect_package(self) -> str:
          """Automatically detects the type of package"""
          return self._package.detect_package()

     def package_available(self, package: str) -> bool:
          """Tells if the given package is available"""
          return self._package.package_available(package)

     def package_clean(self, package=None):
          """Clean the repository for un-needed files."""
          return self._package.package_clean(package)

     def package_ensure(self, package, update=False):
          """Tests if the given package is installed, and installs it in
        case it's not already there. If `update` is true, then the
        package will be updated if it already exists."""
          return self._package.package_ensure(package, update)

     def package_install(self, package, update=False):
          """Installs the given package/list of package, optionally updating
        the package database."""
          return self._package.package_install(package, update)

     def package_installed(self, package, update=False) -> bool:
          """Tells if the given package is installed or not."""
          return self._package.package_installed(package, update)

     def package_remove(self, package, autoclean=False):
          """Remove package and optionally clean unused packages"""
          return self._package.package_remove(package, autoclean)

     def package_update(self, package=None):
          """Updates the package database (when no argument) or update the package
        or list of packages given as argument."""
          return self._package.package_update(package)

     def package_upgrade(self, distupgrade=False):
          """Updates every package present on the system."""
          return self._package.package_upgrade(distupgrade)

     def select_package(self, type: str) -> bool:
          """None"""
          return self._package.select_package(type)

     def package_available_apt(package: str) -> bool:
          """None"""
          return self._packageapt.package_available_apt()

     def package_clean_apt(self, package=None):
          """None"""
          return self._packageapt.package_clean_apt(package)

     def package_ensure_apt(self, package, update=False):
          """Ensure apt packages are installed"""
          return self._packageapt.package_ensure_apt(package, update)

     def package_install_apt(self, package, update=False):
          """None"""
          return self._packageapt.package_install_apt(package, update)

     def package_installed_apt(self, package, update=False) -> False:
          """None"""
          return self._packageapt.package_installed_apt(package, update)

     def package_remove_apt(self, package, autoclean=False):
          """None"""
          return self._packageapt.package_remove_apt(package, autoclean)

     def package_update_apt(self, package=None):
          """None"""
          return self._packageapt.package_update_apt(package)

     def package_upgrade_apt(self, distupgrade=False):
          """None"""
          return self._packageapt.package_upgrade_apt(distupgrade)

     def repository_ensure_apt(self, repository):
          """None"""
          return self._packageapt.repository_ensure_apt(repository)

     def package_clean_yum(self, package=None):
          """None"""
          return self._packageyum.package_clean_yum(package)

     def package_ensure_yum(self, package, update=False):
          """None"""
          return self._packageyum.package_ensure_yum(package, update)

     def package_install_yum(self, package, update=False):
          """None"""
          return self._packageyum.package_install_yum(package, update)

     def package_remove_yum(self, package, autoclean=False):
          """None"""
          return self._packageyum.package_remove_yum(package, autoclean)

     def package_update_yum(self, package=None):
          """None"""
          return self._packageyum.package_update_yum(package)

     def package_upgrade_yum():
          """None"""
          return self._packageyum.package_upgrade_yum()

     def repository_ensure_yum(self, repository: str):
          """None"""
          return self._packageyum.repository_ensure_yum(repository)

     def python_package_ensure_pip(self, package=None, local=True):
          """None"""
          return self._pythonpippackage.python_package_ensure_pip(package, local)

     def python_package_install_pip(self, package=None, local=True):
          """None"""
          return self._pythonpippackage.python_package_install_pip(package, local)

     def python_package_remove_pip(self, package, local=True):
          """None"""
          return self._pythonpippackage.python_package_remove_pip(package, local)

     def python_package_upgrade_pip(self, package=None, local=True):
          """None"""
          return self._pythonpippackage.python_package_upgrade_pip(package, local)

     def detect_python_package(self) -> str:
          """Automatically detects the type of package"""
          return self._pythonpackage.detect_python_package()

     def python_package_ensure(self, package):
          """Tests if the given python package is installed, and installs it in
        case it's not already there."""
          return self._pythonpackage.python_package_ensure(package)

     def python_package_install(self, package=None):
          """Installs the given python package/list of python packages."""
          return self._pythonpackage.python_package_install(package)

     def python_package_remove(self, package):
          """Removes the given python package. """
          return self._pythonpackage.python_package_remove(package)

     def python_package_upgrade(self, package):
          """Upgraded the given Python package"""
          return self._pythonpackage.python_package_upgrade(package)

     def select_python_package(self, type: str) -> bool:
          """None"""
          return self._pythonpackage.select_python_package(type)

     def ssh_authorize(self, user: str, key: Optional[str] = None) -> bool:
          """Adds the given key to the '.ssh/authorized_keys' for the given
        user."""
          return self._ssh.ssh_authorize(user, key)

     def ssh_keygen(self, user: str, keytype='rsa') -> str:
          """Generates a pair of ssh keys in the user's home .ssh directory."""
          return self._ssh.ssh_keygen(user, keytype)

     def ssh_unauthorize(self, user: str, key: str):
          """Removes the given key to the remote '.ssh/authorized_keys' for the given
        user."""
          return self._ssh.ssh_unauthorize(user, key)

     def tmux_is_responsive(self, session: str, window: str) -> bool:
          """None"""
          return self._tmux.tmux_is_responsive(session, window)

     def tmux_session_list(self) -> List[str]:
          """None"""
          return self._tmux.tmux_session_list()

     def tmux_window_list(self, session: str) -> List[str]:
          """None"""
          return self._tmux.tmux_window_list(session)

     def detect_user(self) -> str:
          """None"""
          return self._user.detect_user()

     def user_create(self, name: str, passwd: Optional[str] = None, home: Optional[str] = None, uid: Optional[int] = None, gid: Optional[int] = None, shell: Optional[str] = None, uid_min: Optional[int] = None, uid_max: Optional[int] = None, encrypted_passwd: Optional[bool] = True, fullname: Optional[str] = None, create_home: Optional[bool] = True):
          """Creates the user with the given name, optionally giving a
        specific password/home/uid/gid/shell."""
          return self._user.user_create(name, passwd, home, uid, gid, shell, uid_min, uid_max, encrypted_passwd, fullname, create_home)

     def user_ensure(self, name: str, passwd: Optional[str] = None, home: Optional[str] = None, uid: Optional[int] = None, gid: Optional[int] = None, shell: Optional[str] = None, uid_min: Optional[int] = None, uid_max: Optional[int] = None, encrypted_passwd: Optional[bool] = True, fullname: Optional[str] = None, create_home: Optional[bool] = True):
          """Ensures that the given users exists, optionally updating their
        passwd/home/uid/gid/shell."""
          return self._user.user_ensure(name, passwd, home, uid, gid, shell, uid_min, uid_max, encrypted_passwd, fullname, create_home)

     def user_exists(self, name: str) -> bool:
          """Tells if the user exists."""
          return self._user.user_exists(name)

     def user_get(self, name: Optional[str] = None, uid: Optional[int] = None) -> Dict:
          """Checks if there is a user defined with the given name,
        returning its information as a
        '{"name":<str>,"uid":<str>,"gid":<str>,"home":<str>,"shell":<str>}'
        or 'None' if the user does not exists.
        need_passwd (Boolean) indicates if password to be included in result or not.
                If set to True it parses 'getent shadow' and needs sudo access
        """
          return self._user.user_get(name, uid)

     def user_passwd(self, name: str, passwd: str, encrypted_passwd=True):
          """Sets the given user password. Password is expected to be encrypted by default."""
          return self._user.user_passwd(name, passwd, encrypted_passwd)

     def user_remove(self, name: str, remove_home: bool = False):
          """Removes the user with the given name, optionally
        removing the home directory and mail spool."""
          return self._user.user_remove(name, remove_home)

# EOF
