# NOTE: This is automatically generated by `python -m cuisine.api -t repl`, do not edit
from typing import Tuple, List, Dict, Optional, Union, ForwardRef, ContextManager
import cuisine.connection
import pathlib
from ._impl import API
__API = None
def default_api():
     global __API
     if not __API: __API = API()
     return __API


def cd( path: str) -> ContextManager:
     """Changes the current connection path, returning a context that can be
        used like so:

        ```python
        cd("~")
        with cd("/etc"):
            run("ls -l")
        # Current path will be "~"
        ```
        """
     return default_api().cd(path)

def command( name: str) -> str:
     """Returns the normalized command name. This first tries to find a match
        in `DEFAULT_COMMANDS` and extract it, and then look for a `COMMAND_{name}`
        in the environment."""
     return default_api().command(name)

def command_check( command: str) -> bool:
     """Tests if the given command is available on the system."""
     return default_api().command_check(command)

def command_ensure( command: str, package=None) -> bool:
     """Ensures that the given command is present, if not installs the
        package with the given name, which is the same as the command by
        default."""
     return default_api().command_ensure(command, package)

def config_clear( variable: str) -> Optional[str]:
     """Clears the given `variable` from connection's environment.
        `default` if not found."""
     return default_api().config_clear(variable)

def config_get( variable: str, default: Optional[str] = None) -> Optional[str]:
     """Returns the given `variable` from the connection's environment, returning
        `default` if not found."""
     return default_api().config_get(variable, default)

def config_get_variant( group: str) -> Optional[str]:
     """None"""
     return default_api().config_get_variant(group)

def config_has( variable: str) -> bool:
     """Sets the given `variable` in the connection's environment, returning
        `default` if not found."""
     return default_api().config_has(variable)

def config_set( variable: str, value: str) -> str:
     """Sets the given `variable` in the connection's environment, returning
        `default` if not found."""
     return default_api().config_set(variable, value)

def connect( host=None, port=None, user=None, password=None, key: Union[str, pathlib.Path] = None, transport: Optional[str] = None) -> ContextManager:
     """Connects to the given host/port using the given user/password/key_path credentials. Note that
        not all connection types support all these arguments, so you might get warnings if they are
        not supported."""
     return default_api().connect(host, port, user, password, key, transport)

def connect_local() -> ContextManager:
     """None"""
     return default_api().connect_local()

def connect_mitogen( host=None, port=None, user=None, password=None, key: Optional[pathlib.Path] = None) -> ContextManager:
     """None"""
     return default_api().connect_mitogen(host, port, user, password, key)

def connect_parallelssh( host=None, port=None, user=None, password=None, key: Optional[pathlib.Path] = None) -> ContextManager:
     """None"""
     return default_api().connect_parallelssh(host, port, user, password, key)

def connect_paramiko( host=None, port=None, user=None, password=None, key: Optional[pathlib.Path] = None) -> ContextManager:
     """None"""
     return default_api().connect_paramiko(host, port, user, password, key)

def connect_tmux( session: str, window: str) -> ContextManager:
     """Creates a new connection using the TmuxConnection"""
     return default_api().connect_tmux(session, window)

def connection() -> cuisine.connection.Connection:
     """Returns the current connection"""
     return default_api().connection()

def detect_connection() -> str:
     """Detects the recommended type of connection"""
     return default_api().detect_connection()

def detect_package() -> str:
     """Automatically detects the type of package"""
     return default_api().detect_package()

def detect_python_package() -> str:
     """Automatically detects the type of package"""
     return default_api().detect_python_package()

def detect_user() -> str:
     """None"""
     return default_api().detect_user()

def dir_attribs( path: str, mode=None, owner=None, group=None, recursive=False):
     """Updates the mode/owner/group for the given remote directory."""
     return default_api().dir_attribs(path, mode, owner, group, recursive)

def dir_ensure( path: str, recursive=True, mode=None, owner=None, group=None) -> str:
     """Ensures that there is a remote directory at the given path,
        optionally updating its mode/owner/group.

        If we are not updating the owner/group then this can be done as a single
        ssh call, so use that method, otherwise set owner/group after creation."""
     return default_api().dir_ensure(path, recursive, mode, owner, group)

def dir_ensure_parent( path: str):
     """Ensures that the parent directory of the given path exists"""
     return default_api().dir_ensure_parent(path)

def dir_exists( path: str) -> bool:
     """Tells if there is a remote directory at the given path."""
     return default_api().dir_exists(path)

def dir_remove( path: str, recursive=True):
     """ Removes a directory """
     return default_api().dir_remove(path, recursive)

def disconnect() -> Optional[cuisine.connection.Connection]:
     """Disconnects from the current connection unless it'"s the default
        local connection."""
     return default_api().disconnect()

def env_clear( variable: str) -> str:
     """Clears the given `variable` from connection's environment.
        `default` if not found."""
     return default_api().env_clear(variable)

def env_get( variable: str, default: Optional[str] = None) -> str:
     """Returns the given `variable` from the connection's environment, returning
        `default` if not found."""
     return default_api().env_get(variable, default)

def env_set( variable: str, value: str) -> str:
     """Sets the given `variable` in the connection's environment, returning
        `default` if not found."""
     return default_api().env_set(variable, value)

def fail( message: Optional[str] = None):
     """None"""
     return default_api().fail(message)

def file_append( path: str, content: Union[bytes, str], mode: Optional[str] = None, owner: Optional[str] = None, group: Optional[str] = None):
     """Appends the given content to the remote file at the given
        path, optionally updating its mode/owner/group."""
     return default_api().file_append(path, content, mode, owner, group)

def file_attribs( path: str, mode=None, owner=None, group=None):
     """Updates the mode/owner/group for the remote file at the given
        path."""
     return default_api().file_attribs(path, mode, owner, group)

def file_attribs_get( path: str) -> Dict[str, str]:
     """Return mode, owner, and group for remote path.
        Return mode, owner, and group if remote path exists, 'None'
        otherwise.
        """
     return default_api().file_attribs_get(path)

def file_backup( path: str, suffix='.orig', once=False):
     """Backups the file at the given path in the same directory, appending
        the given suffix. If `once` is True, then the backup will be skipped if
        there is already a backup file."""
     return default_api().file_backup(path, suffix, once)

def file_base64( path: str) -> str:
     """Returns the base64-encoded content of the file at the given path."""
     return default_api().file_base64(path)

def file_ensure( path, mode=None, owner=None, group=None, scp=False):
     """Updates the mode/owner/group for the remote file at the given
        path."""
     return default_api().file_ensure(path, mode, owner, group, scp)

def file_exists( path: str) -> bool:
     """Tests if there is a *remote* file at the given path."""
     return default_api().file_exists(path)

def file_is_dir( path: str) -> bool:
     """Tells if the given path is a directory or not"""
     return default_api().file_is_dir(path)

def file_is_file( path: str):
     """Tells if the given path is a file or not"""
     return default_api().file_is_file(path)

def file_is_link( path: str) -> bool:
     """Tells if the given path is a symlink or not"""
     return default_api().file_is_link(path)

def file_link( source, destination, symbolic=True, mode=None, owner=None, group=None):
     """Creates a (symbolic) link between source and destination on the remote host,
        optionally setting its mode/owner/group."""
     return default_api().file_link(source, destination, symbolic, mode, owner, group)

def file_md5( path: str):
     """Returns the MD5 sum (as a hex string) for the remote file at the given path."""
     return default_api().file_md5(path)

def file_name( path: str) -> str:
     """Returns the file name for the given path."""
     return default_api().file_name(path)

def file_read( path: str) -> bytes:
     """Reads the *remote* file at the given path, if default is not `None`,
        default will be returned if the file does not exist."""
     return default_api().file_read(path)

def file_read_str( path: str) -> str:
     """None"""
     return default_api().file_read_str(path)

def file_sha256( path: str):
     """Returns the SHA-256 sum (as a hex string) for the remote file at the given path."""
     return default_api().file_sha256(path)

def file_unlink( path: str):
     """Removes the given file path if it exists"""
     return default_api().file_unlink(path)

def file_update( path: str, updater=None):
     """Updates the content of the given by passing the existing
        content of the remote file at the given path to the 'updater'
        function. Return true if file content was changed.

        For instance, if you'd like to convert an existing file to all
        uppercase, simply do:

        >   file_update("/etc/myfile", lambda _:_.upper())

        Or restart service on config change:

        >   if file_update("/etc/myfile.cfg", lambda _: text_ensure_line(_, line)): run("service restart")
        """
     return default_api().file_update(path, updater)

def file_upload( local: str, remote: str):
     """Uploads the local file to the remote path only if the remote path does not
        exists or the content are different."""
     return default_api().file_upload(local, remote)

def file_write( path: str, content: Union[str, bytes], mode=None, owner=None, group=None, sudo=None, check=True, scp=False):
     """Writes the given content to the file at the given remote
        path, optionally setting mode/owner/group."""
     return default_api().file_write(path, content, mode, owner, group, sudo, check, scp)

def is_local() -> bool:
     """Tells if the current connection is local or not."""
     return default_api().is_local()

def package_available( package: str) -> bool:
     """Tells if the given package is available"""
     return default_api().package_available(package)

def package_available_apt(package: str) -> bool:
     """None"""
     return default_api().package_available_apt()

def package_clean( package=None):
     """Clean the repository for un-needed files."""
     return default_api().package_clean(package)

def package_clean_apt( package=None):
     """None"""
     return default_api().package_clean_apt(package)

def package_clean_yum( package=None):
     """None"""
     return default_api().package_clean_yum(package)

def package_ensure( package, update=False):
     """Tests if the given package is installed, and installs it in
        case it's not already there. If `update` is true, then the
        package will be updated if it already exists."""
     return default_api().package_ensure(package, update)

def package_ensure_apt( package, update=False):
     """Ensure apt packages are installed"""
     return default_api().package_ensure_apt(package, update)

def package_ensure_yum( package, update=False):
     """None"""
     return default_api().package_ensure_yum(package, update)

def package_install( package, update=False):
     """Installs the given package/list of package, optionally updating
        the package database."""
     return default_api().package_install(package, update)

def package_install_apt( package, update=False):
     """None"""
     return default_api().package_install_apt(package, update)

def package_install_yum( package, update=False):
     """None"""
     return default_api().package_install_yum(package, update)

def package_installed( package, update=False) -> bool:
     """Tells if the given package is installed or not."""
     return default_api().package_installed(package, update)

def package_installed_apt( package, update=False) -> False:
     """None"""
     return default_api().package_installed_apt(package, update)

def package_remove( package, autoclean=False):
     """Remove package and optionally clean unused packages"""
     return default_api().package_remove(package, autoclean)

def package_remove_apt( package, autoclean=False):
     """None"""
     return default_api().package_remove_apt(package, autoclean)

def package_remove_yum( package, autoclean=False):
     """None"""
     return default_api().package_remove_yum(package, autoclean)

def package_update( package=None):
     """Updates the package database (when no argument) or update the package
        or list of packages given as argument."""
     return default_api().package_update(package)

def package_update_apt( package=None):
     """None"""
     return default_api().package_update_apt(package)

def package_update_yum( package=None):
     """None"""
     return default_api().package_update_yum(package)

def package_upgrade( distupgrade=False):
     """Updates every package present on the system."""
     return default_api().package_upgrade(distupgrade)

def package_upgrade_apt( distupgrade=False):
     """None"""
     return default_api().package_upgrade_apt(distupgrade)

def package_upgrade_yum():
     """None"""
     return default_api().package_upgrade_yum()

def python_package_ensure( package):
     """Tests if the given python package is installed, and installs it in
        case it's not already there."""
     return default_api().python_package_ensure(package)

def python_package_ensure_pip( package=None, local=True):
     """None"""
     return default_api().python_package_ensure_pip(package, local)

def python_package_install( package=None):
     """Installs the given python package/list of python packages."""
     return default_api().python_package_install(package)

def python_package_install_pip( package=None, local=True):
     """None"""
     return default_api().python_package_install_pip(package, local)

def python_package_remove( package):
     """Removes the given python package. """
     return default_api().python_package_remove(package)

def python_package_remove_pip( package, local=True):
     """None"""
     return default_api().python_package_remove_pip(package, local)

def python_package_upgrade( package):
     """Upgraded the given Python package"""
     return default_api().python_package_upgrade(package)

def python_package_upgrade_pip( package=None, local=True):
     """None"""
     return default_api().python_package_upgrade_pip(package, local)

def repository_ensure_apt( repository):
     """None"""
     return default_api().repository_ensure_apt(repository)

def repository_ensure_yum( repository: str):
     """None"""
     return default_api().repository_ensure_yum(repository)

def run( command: str) -> 'CommandOutput':
     """None"""
     return default_api().run(command)

def run_local( command: str) -> 'CommandOutput':
     """None"""
     return default_api().run_local(command)

def select_connection( type: str) -> bool:
     """Selects the default type of connection. This returns `False` in case
        the connection is not found."""
     return default_api().select_connection(type)

def select_package( type: str) -> bool:
     """None"""
     return default_api().select_package(type)

def select_python_package( type: str) -> bool:
     """None"""
     return default_api().select_python_package(type)

def ssh_authorize( user: str, key: Optional[str] = None) -> bool:
     """Adds the given key to the '.ssh/authorized_keys' for the given
        user."""
     return default_api().ssh_authorize(user, key)

def ssh_keygen( user: str, keytype='rsa') -> str:
     """Generates a pair of ssh keys in the user's home .ssh directory."""
     return default_api().ssh_keygen(user, keytype)

def ssh_unauthorize( user: str, key: str):
     """Removes the given key to the remote '.ssh/authorized_keys' for the given
        user."""
     return default_api().ssh_unauthorize(user, key)

def sudo( command: Optional[str] = None) -> Union[ContextManager, ForwardRef('CommandOutput')]:
     """None"""
     return default_api().sudo(command)

def tmux_is_responsive( session: str, window: str) -> bool:
     """None"""
     return default_api().tmux_is_responsive(session, window)

def tmux_session_list() -> List[str]:
     """None"""
     return default_api().tmux_session_list()

def tmux_window_list( session: str) -> List[str]:
     """None"""
     return default_api().tmux_window_list(session)

def user_create( name: str, passwd: Optional[str] = None, home: Optional[str] = None, uid: Optional[int] = None, gid: Optional[int] = None, shell: Optional[str] = None, uid_min: Optional[int] = None, uid_max: Optional[int] = None, encrypted_passwd: Optional[bool] = True, fullname: Optional[str] = None, create_home: Optional[bool] = True):
     """Creates the user with the given name, optionally giving a
        specific password/home/uid/gid/shell."""
     return default_api().user_create(name, passwd, home, uid, gid, shell, uid_min, uid_max, encrypted_passwd, fullname, create_home)

def user_create_linux( name: str, passwd: Optional[str] = None, home: Optional[str] = None, uid: Optional[int] = None, gid: Optional[int] = None, shell: Optional[str] = None, uid_min: Optional[int] = None, uid_max: Optional[int] = None, encrypted_passwd: Optional[bool] = True, fullname: Optional[str] = None, create_home: Optional[bool] = True):
     """None"""
     return default_api().user_create_linux(name, passwd, home, uid, gid, shell, uid_min, uid_max, encrypted_passwd, fullname, create_home)

def user_ensure( name: str, passwd: Optional[str] = None, home: Optional[str] = None, uid: Optional[int] = None, gid: Optional[int] = None, shell: Optional[str] = None, uid_min: Optional[int] = None, uid_max: Optional[int] = None, encrypted_passwd: Optional[bool] = True, fullname: Optional[str] = None, create_home: Optional[bool] = True):
     """Ensures that the given users exists, optionally updating their
        passwd/home/uid/gid/shell."""
     return default_api().user_ensure(name, passwd, home, uid, gid, shell, uid_min, uid_max, encrypted_passwd, fullname, create_home)

def user_ensure_linux( name: str, passwd: Optional[str] = None, home: Optional[str] = None, uid: Optional[int] = None, gid: Optional[int] = None, shell: Optional[str] = None, uid_min: Optional[int] = None, uid_max: Optional[int] = None, encrypted_passwd: Optional[bool] = True, fullname: Optional[str] = None, create_home: Optional[bool] = True):
     """None"""
     return default_api().user_ensure_linux(name, passwd, home, uid, gid, shell, uid_min, uid_max, encrypted_passwd, fullname, create_home)

def user_exists( name: str) -> bool:
     """Tells if the user exists."""
     return default_api().user_exists(name)

def user_exists_linux( name: str) -> bool:
     """None"""
     return default_api().user_exists_linux(name)

def user_get( name: Optional[str] = None, uid: Optional[int] = None) -> Dict:
     """Checks if there is a user defined with the given name,
        returning its information as a
        '{"name":<str>,"uid":<str>,"gid":<str>,"home":<str>,"shell":<str>}'
        or 'None' if the user does not exists.
        need_passwd (Boolean) indicates if password to be included in result or not.
                If set to True it parses 'getent shadow' and needs sudo access
        """
     return default_api().user_get(name, uid)

def user_get_linux( name: str = None, uid: int = None):
     """None"""
     return default_api().user_get_linux(name, uid)

def user_passwd( name: str, passwd: str, encrypted_passwd=True):
     """Sets the given user password. Password is expected to be encrypted by default."""
     return default_api().user_passwd(name, passwd, encrypted_passwd)

def user_passwd_linux( name: str, passwd: str, encrypted_passwd=True):
     """Sets the given user password. Password is expected to be encrypted by default."""
     return default_api().user_passwd_linux(name, passwd, encrypted_passwd)

def user_remove( name: str, remove_home: bool = False):
     """Removes the user with the given name, optionally
        removing the home directory and mail spool."""
     return default_api().user_remove(name, remove_home)

def user_remove_linux( name: str, remove_home: bool = False):
     """Removes the user with the given name, optionally
        removing the home directory and mail spool."""
     return default_api().user_remove_linux(name, remove_home)

# EOF
