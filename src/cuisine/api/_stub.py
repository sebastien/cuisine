# NOTE: This is automatically generated by `python -m cuisine.api -t stub`, do not edit
class API:

     def command(self, name: str) -> str:
          """Returns the normalized command name. This first tries to find a match 
        in `DEFAULT_COMMANDS` and extract it, and then look for a `COMMAND_{name}`
        in the environment."""
          raise NotImplementedError

     def command_check(self, command: str) -> bool:
          """Tests if the given command is available on the system."""
          raise NotImplementedError

     def command_ensure(self, command: str, package=None) -> bool:
          """Ensures that the given command is present, if not installs the
        package with the given name, which is the same as the command by
        default."""
          raise NotImplementedError

     def run(self, command: str) -> 'CommandOutput':
          """None"""
          raise NotImplementedError

     def dir_attribs(self, path: str, mode=None, owner=None, group=None, recursive=False):
          """Updates the mode/owner/group for the given remote directory."""
          raise NotImplementedError

     def dir_ensure(self, path: str, recursive=True, mode=None, owner=None, group=None) -> str:
          """Ensures that there is a remote directory at the given path,
        optionally updating its mode/owner/group.

        If we are not updating the owner/group then this can be done as a single
        ssh call, so use that method, otherwise set owner/group after creation."""
          raise NotImplementedError

     def dir_ensure_parent(self, path: str):
          """Ensures that the parent directory of the given path exists"""
          raise NotImplementedError

     def dir_exists(self, path: str) -> bool:
          """Tells if there is a remote directory at the given path."""
          raise NotImplementedError

     def dir_remove(self, path: str, recursive=True):
          """ Removes a directory """
          raise NotImplementedError

     def file_append(self, path, content, mode=None, owner=None, group=None):
          """Appends the given content to the remote file at the given
        path, optionally updating its mode/owner/group."""
          raise NotImplementedError

     def file_attribs_get(self, path):
          """Return mode, owner, and group for remote path.
        Return mode, owner, and group if remote path exists, 'None'
        otherwise.
        """
          raise NotImplementedError

     def file_backup(self, path: str, suffix='.orig', once=False):
          """Backups the file at the given path in the same directory, appending
        the given suffix. If `once` is True, then the backup will be skipped if
        there is already a backup file."""
          raise NotImplementedError

     def file_base64(self, path: str):
          """Returns the base64-encoded content of the file at the given path."""
          raise NotImplementedError

     def file_ensure(self, path, mode=None, owner=None, group=None, scp=False):
          """Updates the mode/owner/group for the remote file at the given
        path."""
          raise NotImplementedError

     def file_exists(self, path: str) -> bool:
          """Tests if there is a *remote* file at the given path."""
          raise NotImplementedError

     def file_is_dir(self, path: str) -> bool:
          """None"""
          raise NotImplementedError

     def file_is_file(self, path):
          """None"""
          raise NotImplementedError

     def file_is_link(self, path: str) -> bool:
          """None"""
          raise NotImplementedError

     def file_link(self, source, destination, symbolic=True, mode=None, owner=None, group=None):
          """Creates a (symbolic) link between source and destination on the remote host,
        optionally setting its mode/owner/group."""
          raise NotImplementedError

     def file_md5(self, path: str):
          """Returns the MD5 sum (as a hex string) for the remote file at the given path."""
          raise NotImplementedError

     def file_name(self, path: str) -> str:
          """Returns the file name for the given path."""
          raise NotImplementedError

     def file_read(self, path, default=None):
          """Reads the *remote* file at the given path, if default is not `None`,
        default will be returned if the file does not exist."""
          raise NotImplementedError

     def file_unlink(self, path: str):
          """None"""
          raise NotImplementedError

     def file_update(self, path: str, updater=None):
          """Updates the content of the given by passing the existing
        content of the remote file at the given path to the 'updater'
        function. Return true if file content was changed.

        For instance, if you'd like to convert an existing file to all
        uppercase, simply do:

        >   file_update("/etc/myfile", lambda _:_.upper())

        Or restart service on config change:

        >   if file_update("/etc/myfile.cfg", lambda _: text_ensure_line(_, line)): run("service restart")
        """
          raise NotImplementedError

     def file_upload(self, local, remote, sudo=None, scp=False):
          """Uploads the local file to the remote path only if the remote path does not
        exists or the content are different."""
          raise NotImplementedError

     def file_write(self, path: str, content: bytes, mode=None, owner=None, group=None, sudo=None, check=True, scp=False):
          """Writes the given content to the file at the given remote
        path, optionally setting mode/owner/group."""
          raise NotImplementedError

# EOF
